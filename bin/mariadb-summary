#!/bin/bash

# This program is part of MariaDB client tools
# See "COPYRIGHT, LICENSE, AND WARRANTY" at the end of this file for legal
# notices and disclaimers.

set -u

# ########################################################################
# Globals, settings, helper functions
# ########################################################################
TOOL="mariadb-summary"
POSIXLY_CORRECT=1
export POSIXLY_CORRECT
export OS=`uname`

# ###########################################################################
# log_warn_die package
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the Bazaar repository at,
#   lib/bash/log_warn_die.sh
#   t/lib/bash/log_warn_die.sh
# ###########################################################################


set -u

PTFUNCNAME=""
PTDEBUG="${PTDEBUG:-""}"
EXIT_STATUS=0

ts() {
   TS=$(date +%F-%T | tr ':-' '_')
   echo "$TS $*"
}

info() {
   [ ${OPT_VERBOSE:-3} -ge 3 ] && ts "$*"
}

log() {
   [ ${OPT_VERBOSE:-3} -ge 2 ] && ts "$*"
}

warn() {
   [ ${OPT_VERBOSE:-3} -ge 1 ] && ts "$*" >&2
   EXIT_STATUS=1
}

die() {
   ts "$*" >&2
   EXIT_STATUS=1
   exit 1
}

_d () {
   [ "$PTDEBUG" ] && echo "# $PTFUNCNAME: $(ts "$*")" >&2
}

# ###########################################################################
# End log_warn_die package
# ###########################################################################

# ###########################################################################
# parse_options package
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the Bazaar repository at,
#   lib/bash/parse_options.sh
#   t/lib/bash/parse_options.sh
# ###########################################################################





set -u

ARGV=""           # Non-option args (probably input files)
EXT_ARGV=""       # Everything after -- (args for an external command)
HAVE_EXT_ARGV=""  # Got --, everything else is put into EXT_ARGV
OPT_ERRS=0        # How many command line option errors
OPT_VERSION=""    # If --version was specified
OPT_HELP=""       # If --help was specified
OPT_ASK_PASS=""   # If --ask-pass was specified
PO_DIR=""         # Directory with program option spec files

usage() {
   local file="$1"

   local usage="$(grep '^Usage: ' "$file")"
   echo $usage
   echo
   echo "For more information, 'man $TOOL' or 'perldoc $file'."
}

usage_or_errors() {
   local file="$1"
   local version=""

   if [ "$OPT_VERSION" ]; then
      version=$(grep '^mariadb-[^ ]\+ [0-9]' "$file")
      echo "$version"
      return 1
   fi

   if [ "$OPT_HELP" ]; then
      usage "$file"
      echo
      echo "Command line options:"
      echo
      perl -e '
         use strict;
         use warnings FATAL => qw(all);
         my $lcol = 20;         # Allow this much space for option names.
         my $rcol = 80 - $lcol; # The terminal is assumed to be 80 chars wide.
         my $name;
         while ( <> ) {
            my $line = $_;
            chomp $line;
            if ( $line =~ s/^long:/  --/ ) {
               $name = $line;
            }
            elsif ( $line =~ s/^desc:// ) {
               $line =~ s/ +$//mg;
               my @lines = grep { $_      }
                           $line =~ m/(.{0,$rcol})(?:\s+|\Z)/g;
               if ( length($name) >= $lcol ) {
                  print $name, "\n", (q{ } x $lcol);
               }
               else {
                  printf "%-${lcol}s", $name;
               }
               print join("\n" . (q{ } x $lcol), @lines);
               print "\n";
            }
         }
      ' "$PO_DIR"/*
      echo
      echo "Options and values after processing arguments:"
      echo
      (
         cd "$PO_DIR"
         for opt in *; do
            local varname="OPT_$(echo "$opt" | tr a-z- A-Z_)"
            eval local varvalue=\$$varname
            if ! grep -q "type:" "$PO_DIR/$opt" >/dev/null; then
               if [ "$varvalue" -a "$varvalue" = "yes" ];
                  then varvalue="TRUE"
               else
                  varvalue="FALSE"
               fi
            fi
            printf -- "  --%-30s %s" "$opt" "${varvalue:-(No value)}"
            echo
         done
      )
      return 1
   fi

   if [ $OPT_ERRS -gt 0 ]; then
      echo
      usage "$file"
      return 1
   fi

   return 0
}

option_error() {
   local err="$1"
   OPT_ERRS=$(($OPT_ERRS + 1))
   echo "$err" >&2
}

parse_options() {
   local file="$1"
   shift

   ARGV=""
   EXT_ARGV=""
   HAVE_EXT_ARGV=""
   OPT_ERRS=0
   OPT_VERSION=""
   OPT_HELP=""
   OPT_ASK_PASS=""
   PO_DIR="$PT_TMPDIR/po"

   if [ ! -d "$PO_DIR" ]; then
      mkdir "$PO_DIR"
      if [ $? -ne 0 ]; then
         echo "Cannot mkdir $PO_DIR" >&2
         exit 1
      fi
   fi

   rm -rf "$PO_DIR"/*
   if [ $? -ne 0 ]; then
      echo "Cannot rm -rf $PO_DIR/*" >&2
      exit 1
   fi

   _parse_pod "$file"  # Parse POD into program option (po) spec files
   _eval_po            # Eval po into existence with default values

   if [ $# -ge 2 ] &&  [ "$1" = "--config" ]; then
      shift  # --config
      local user_config_files="$1"
      shift  # that ^
      local IFS=","
      for user_config_file in $user_config_files; do
         _parse_config_files "$user_config_file"
      done
   else
      _parse_config_files "/etc/mariadb/mariadb-tools.conf" "/etc/mariadb/$TOOL.conf"
      if [ "${HOME:-}" ]; then
         _parse_config_files "$HOME/.mariadb-tools.conf" "$HOME/.$TOOL.conf"
      fi
   fi

   _parse_command_line "${@:-""}"
}

_parse_pod() {
local file="$1"

   PO_FILE="$file" PO_DIR="$PO_DIR" perl -e '
      $/ = "";
      my $file = $ENV{PO_FILE};
      open my $fh, "<", $file or die "Cannot open $file: $!";
      while ( defined(my $para = <$fh>) ) {
         next unless $para =~ m/^=head1 OPTIONS/;
         while ( defined(my $para = <$fh>) ) {
            last if $para =~ m/^=head1/;
            chomp;
            if ( $para =~ m/^=item --(\S+)/ ) {
               my $opt  = $1;
               my $file = "$ENV{PO_DIR}/$opt";
               open my $opt_fh, ">", $file or die "Cannot open $file: $!";
               print $opt_fh "long:$opt\n";
               $para = <$fh>;
               chomp;
               if ( $para =~ m/^[a-z ]+:/ ) {
                  map {
                     chomp;
                     my ($attrib, $val) = split(/: /, $_);
                     print $opt_fh "$attrib:$val\n";
                  } split(/; /, $para);
                  $para = <$fh>;
                  chomp;
               }
               my ($desc) = $para =~ m/^([^?.]+)/;
               print $opt_fh "desc:$desc.\n";
               close $opt_fh;
            }
         }
         last;
      }
   '
}

_eval_po() {
   local IFS=":"
   for opt_spec in "$PO_DIR"/*; do
      local opt=""
      local default_val=""
      local neg=0
      local size=0
      while read key val; do
         case "$key" in
            long)
               opt=$(echo $val | sed 's/-/_/g' | tr '[:lower:]' '[:upper:]')
               ;;
            default)
               default_val="$val"
               ;;
            "short form")
               ;;
            type)
               [ "$val" = "size" ] && size=1
               ;;
            desc)
               ;;
            negatable)
               if [ "$val" = "yes" ]; then
                  neg=1
               fi
               ;;
            *)
               echo "Invalid attribute in $opt_spec: $line" >&2
               exit 1
         esac 
      done < "$opt_spec"

      if [ -z "$opt" ]; then
         echo "No long attribute in option spec $opt_spec" >&2
         exit 1
      fi

      if [ $neg -eq 1 ]; then
         if [ -z "$default_val" ] || [ "$default_val" != "yes" ]; then
            echo "Option $opt_spec is negatable but not default: yes" >&2
            exit 1
         fi
      fi

      if [ $size -eq 1 -a -n "$default_val" ]; then
         default_val=$(size_to_bytes $default_val)
      fi

      eval "OPT_${opt}"="$default_val"
   done
}

_parse_config_files() {

   for config_file in "${@:-""}"; do
      test -f "$config_file" || continue

      while read config_opt; do

         echo "$config_opt" | grep '^[ ]*[^#]' >/dev/null 2>&1 || continue

         config_opt="$(echo "$config_opt" | sed -e 's/^ *//g' -e 's/ *$//g' -e 's/[ ]*=[ ]*/=/' -e 's/[ ]+#.*$//')"

         [ "$config_opt" = "" ] && continue

         echo "$config_opt" | grep -v 'version-check' >/dev/null 2>&1 || continue

         if ! [ "$HAVE_EXT_ARGV" ]; then
            config_opt="--$config_opt"
         fi

         _parse_command_line "$config_opt"

      done < "$config_file"

      HAVE_EXT_ARGV=""  # reset for each file

   done
}

_parse_command_line() {
   local opt=""
   local val=""
   local next_opt_is_val=""
   local opt_is_ok=""
   local opt_is_negated=""
   local real_opt=""
   local required_arg=""
   local spec=""

   for opt in "${@:-""}"; do
      if [ "$opt" = "--" -o "$opt" = "----" ]; then
         HAVE_EXT_ARGV=1
         continue
      fi
      if [ "$HAVE_EXT_ARGV" ]; then
         if [ "$EXT_ARGV" ]; then
            EXT_ARGV="$EXT_ARGV $opt"
         else
            EXT_ARGV="$opt"
         fi
         continue
      fi

      if [ "$next_opt_is_val" ]; then
         next_opt_is_val=""
         if [ $# -eq 0 ] || [ $(expr "$opt" : "\-") -eq 1 ]; then
            option_error "$real_opt requires a $required_arg argument"
            continue
         fi
         val="$opt"
         opt_is_ok=1
      else
         if [ $(expr "$opt" : "\-") -eq 0 ]; then
            if [ -z "$ARGV" ]; then
               ARGV="$opt"
            else
               ARGV="$ARGV $opt"
            fi
            continue
         fi

         real_opt="$opt"

         if $(echo $opt | grep '^--no[^-]' >/dev/null); then
            local base_opt=$(echo $opt | sed 's/^--no//')
            if [ -f "$PT_TMPDIR/po/$base_opt" ]; then
               opt_is_negated=1
               opt="$base_opt"
            else
               opt_is_negated=""
               opt=$(echo $opt | sed 's/^-*//')
            fi
         else
            if $(echo $opt | grep '^--no-' >/dev/null); then
               opt_is_negated=1
               opt=$(echo $opt | sed 's/^--no-//')
            else
               opt_is_negated=""
               opt=$(echo $opt | sed 's/^-*//')
            fi
         fi

         if $(echo $opt | grep '^[a-z-][a-z-]*=' >/dev/null 2>&1); then
            val="$(echo $opt | awk -F= '{print $2}')"
            opt="$(echo $opt | awk -F= '{print $1}')"
         fi

         if [ -f "$PT_TMPDIR/po/$opt" ]; then
            spec="$PT_TMPDIR/po/$opt"
         else
            spec=$(grep "^short form:-$opt\$" "$PT_TMPDIR"/po/* | cut -d ':' -f 1)
            if [ -z "$spec"  ]; then
               option_error "Unknown option: $real_opt"
               continue
            fi
         fi

         required_arg=$(cat "$spec" | awk -F: '/^type:/{print $2}')
         if [ "$required_arg" ]; then
            if [ "$val" ]; then
               opt_is_ok=1
            else
               next_opt_is_val=1
            fi
         else
            if [ "$val" ]; then
               option_error "Option $real_opt does not take a value"
               continue
            fi 
            if [ "$opt_is_negated" ]; then
               val=""
            else
               val="yes"
            fi
            opt_is_ok=1
         fi
      fi

      if [ "$opt_is_ok" ]; then
         opt=$(cat "$spec" | grep '^long:' | cut -d':' -f2 | sed 's/-/_/g' | tr '[:lower:]' '[:upper:]')

         if grep "^type:size" "$spec" >/dev/null; then
            val=$(size_to_bytes $val)
         fi

         eval "OPT_$opt"="'$val'"

         opt=""
         val=""
         next_opt_is_val=""
         opt_is_ok=""
         opt_is_negated=""
         real_opt=""
         required_arg=""
         spec=""
      fi
   done
}

size_to_bytes() {
   local size="$1"
   echo $size | perl -ne '%f=(B=>1, K=>1_024, M=>1_048_576, G=>1_073_741_824, T=>1_099_511_627_776); m/^(\d+)([kMGT])?/i; print $1 * $f{uc($2 || "B")};'
}

# ###########################################################################
# End parse_options package
# ###########################################################################

# ###########################################################################
# tmpdir package
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the Bazaar repository at,
#   lib/bash/tmpdir.sh
#   t/lib/bash/tmpdir.sh
# ###########################################################################


set -u

PT_TMPDIR=""

mk_tmpdir() {
   local dir="${1:-""}"

   if [ -n "$dir" ]; then
      if [ ! -d "$dir" ]; then
         mkdir "$dir" || die "Cannot make tmpdir $dir"
      fi
      PT_TMPDIR="$dir"
   else
      local tool="${0##*/}"
      local pid="$$"
      PT_TMPDIR=`mktemp -d -t "${tool}.${pid}.XXXXXX"` \
         || die "Cannot make secure tmpdir"
   fi
}

rm_tmpdir() {
   if [ -n "$PT_TMPDIR" ] && [ -d "$PT_TMPDIR" ]; then
      rm -rf "$PT_TMPDIR"
   fi
   PT_TMPDIR=""
}

# ###########################################################################
# End tmpdir package
# ###########################################################################

# ###########################################################################
# End alt_cmds package
# ###########################################################################

# ###########################################################################
# audit_metrics package
# ###########################################################################

function audit_metrics() {

local dir="${OPT_SUPPORT_OUTPUT_DIR:-`pwd`}"
## TODO: Make sure we honor support metrics if passed in here.
if [ "${OPT_SUPPORT}" == "yes" ] 2>/dev/null || [ "${OPT_SUPPORT}" -le 0 ] 2>/dev/null ; then
   echo "WARN: Either 0 or no value was provided to --support, this will require"
   echo "you to manually ^C (Control-C) when you're satisfied collecting metrics."
   OPT_SUPPORT="ctrlc"
fi

local duration=${OPT_SUPPORT:-$OPT_SUPPORT_METRICS}
# local savedir="" ## Removed for simplifying options.

local outputdir="${dir}/`hostname`_${OPT_SUPPORT_ANNOTATION:-""}metrics_`date +%F`"
local min_free_bytes=2147483648 # 2GB
local min_free_pct=1            # 1%

if [ ! -d $outputdir ]; then
   mkdir -p $outputdir
fi

# local original_opts=(COLLECTSLAVESTATUS COLLECTPROCESSLIST COLLECTINNODBMUTEX COLLECTTOKUDB COLLECTVARIABLES COLLECTAWSAURORA COLLECTMOUNTSTATS ISRDS MARIADB_OPTIONS TARRESULT COLLECTMEMINFO)

local COLLECTSLAVESTATUS=${OPT_SUPPORT_REPLICA_STATUS:-false}
local COLLECTPROCESSLIST=${OPT_SUPPORT_PROCESS_LIST:-false}
local COLLECTINNODBMUTEX=${OPT_SUPPORT_INNODB_MUTEX:-false}
local COLLECTTOKUDB=false # Deprecate me!
local COLLECTVARIABLES=${OPT_SUPPORT_VARIABLES:-false}
local COLLECTAWSAURORA=${OPT_SUPPORT_AURORA:-false}
local COLLECTMOUNTSTATS=${OPT_SUPPORT_MOUNTS:-false}
local COLLECTMEMINFO=${OPT_SUPPORT_MEMORY:-false}
local COLLECTAWSAURORA=${OPT_SUPPORT_SKY:-false}

# this is set by default, so we want to do it first
if [ "$OPT_SUPPORT_CHECKALL" ]; then
   COLLECTMEMINFO=true
   COLLECTSLAVESTATUS=true
   COLLECTPROCESSLIST=true
   COLLECTINNODBMUTEX=true
   COLLECTVARIABLES=true
   COLLECTMOUNTSTATS=true
fi

# Allow overrides of the system --support call, but still allow --support
if [ ! "$OPT_SUPPORT_REPLICA_STATUS" ]; then
   COLLECTSLAVESTATUS=""
else
   COLLECTSLAVESTATUS=$OPT_SUPPORT_REPLICA_STATUS
fi
if [ ! "$OPT_SUPPORT_PROCESS_LIST" ]; then
   COLLECTPROCESSLIST=""
else
   COLLECTPROCESSLIST=$OPT_SUPPORT_PROCESS_LIST
fi
if [ ! "$OPT_SUPPORT_INNODB_MUTEX" ]; then
   COLLECTINNODBMUTEX=""
else
   COLLECTINNODBMUTEX=$OPT_SUPPORT_INNODB_MUTEX
fi
if [ ! "$OPT_SUPPORT_VARIABLES" ]; then
   COLLECTVARIABLES=""
else
   COLLECTVARIABLES=$OPT_SUPPORT_VARIABLES
fi
if [ ! "$OPT_SUPPORT_MOUNTS" ]; then
   COLLECTMOUNTSTATS=""
else
   COLLECTMOUNTSTATS=$OPT_SUPPORT_MOUNTS
fi
if [ ! "$OPT_SUPPORT_MEMORY" ]; then
   COLLECTMEMINFO=""
else
   COLLECTMEMINFO=$OPT_SUPPORT_MEMORY
fi


if [ -n "${OPT_DEBUG}" ]; then
   echo "######### DEBUG MODE #########"
   echo "Parsed variables for metrics are:"
   declare -p | grep COLLECT
   # exit
fi 

local TARRESULT=${OPT_SUPPORT_TAR_RESULT:-true}
local ISRDS=${OPT_SUPPORT_SKY:-false}

if [ -n "${OPT_HOST}" ] && [ -n "${OPT_PORT}" ] && [ -n "${OPT_PASSWORD}" ] && [ -n "${OPT_USER}" ]; then
   local MARIADB_OPTIONS="-h ${OPT_HOST} -P ${OPT_PORT} -p${OPT_PASSWORD} -u ${OPT_USER}"
elif [ -n "${OPT_SOCKET}" ] && [ -n "${OPT_USER}" ] && [ -n "${OPT_PASSWORD}" ]; then
   local MARIADB_OPTIONS="-u ${OPT_USER} -S ${OPT_SOCKET} -p${OPT_PASSWORD}"
elif [ -n "${OPT_DEFAULTS_FILE}" ]; then
   local MARIADB_OPTIONS="--defaults-file=${OPT_DEFAULTS_FILE}"
else
   local MARIADB_OPTIONS=${MARIADB_OPTIONS:-${OPT_MARIADB_OPTIONS:-""}}
fi

if [ -n "${OPT_DEBUG}" ]; then
   echo "DEBUG: MARIADB_OPTIONS set as ${MARIADB_OPTIONS}"
fi

function usage {
  echo ""
  echo "You've hit a bug! Please contact our JIRA board to help us patch this issue for you!"
  echo "https://jira.mariadb.org/projects/TOOLS (be sure to sanitize any relevant personal data!)"
  echo ""
}
local bg_jobs=();

function kill_collection() {
  echo "Collecting last pieces of data ... wait a bit."
  date "+%Y-%m-%d %H:%M:%S" > ${outputdir}/collection_stop
  for pid in "${bg_jobs[@]}"
  do
    echo "Killing pid $pid"
    kill -9 $pid >/dev/null 2>&1
    ps -p $pid >/dev/null 2>&1
    if [ "$?" == "0" ]; then
      wait $pid
    fi
  done
  sleep 3

  if [ $TARRESULT == true ]; then
    echo 'Archiving...'
    tar -czf ${outputdir}.mdbo -C $(dirname ${outputdir}) ./
    rm -rf ${outputdir}
    echo "Filename: ${outputdir}.mdbo"
    else
    echo "Directory Name: ${outputdir}"
  fi
  # exit 0
  echo "Collection Complete. See ${outputdir}. Continuing..."
}


function check_disk_space() {
  exit_on_error=${1:-0}
  set -e
  local disk_space=$(df -P -k $dir | tail -n 1)

  local free_bytes=$(echo $disk_space | perl -ane 'print $F[3] * 1024')
  local pct_used=$(echo $disk_space | perl -ane 'print ($F[4] =~ m/(\d+)/)')
  local pct_free=$((100 - $pct_used))

  local real_free_bytes=$free_bytes
  local real_pct_free=$pct_free

   set +e
  if [ $free_bytes -lt $min_free_bytes -o $pct_free -lt $min_free_pct ]; then
    echo "ERROR: Not enough free disk space:
  Limit: ${min_free_pct}% free or ${min_free_bytes} bytes free
 Actual: ${real_pct_free}% free or ${real_free_bytes} bytes free
"
    if [ $exit_on_error -eq 1 ]; then
      exit 1
    else
      kill_collection
    fi
  fi
  return 0  # disk space is OK
}

# let's do this now and don't do anything if there is no space
check_disk_space 1


function check_binary() {
  local binary=$1
  which $binary &> /dev/null
  if [ "$?" != "0" ]; then
    echo "ERROR: Could not find $binary or it is not executable"
    exit 1
    ## We should offer to install from pkg mgr...

  fi
}

check_binary mariadb-admin
check_binary mariadb
check_binary cat
check_binary gzip
check_binary tar

if [ "$ISRDS" == "false" ]; then
   check_binary mpstat
   check_binary vmstat
   check_binary iostat
fi

## Test MariaDB privileges before doing anything else ##
function check_privileges() {
  local base="show engine innodb status;"

  if [ $COLLECTSLAVESTATUS == true ]; then
    base="$base show slave status;"
  fi

  if [ {COLLECTPROCESSLIST == true ]; then
    base="$base show full processlist;"
  fi

  if [ $COLLECTTOKUDB == true ]; then
    base="$base show engine tokudb status;"
  fi

  mariadb ${MARIADB_OPTIONS} -e "${base}" >/dev/null
  if [ "$?" != "0" ]; then
    echo "ERROR: Missing some privileges."
    exit 1
  fi
}
check_privileges

## get mariadb version, to see if we should fetch 5.6 specific data
local MARIADBVERSION=`mariadb ${MARIADB_OPTIONS} -Ne"select replace(left(version(), 3), '.', '');"`

if [ "$duration" == 'ctrlc' ]; then
  echo "Will collect data until ctrlc is pressed";
else
  if [[ "$duration" =~ ^[0-9]+$ ]]; then
    echo "Will collect data for $duration minutes";
  else
    echo "ERROR: Invalid duration given: $duration";
    usage
    exit 1
  fi
fi

if [ ! -d ${outputdir} ]; then
  mkdir -p ${outputdir}
fi

echo "Writing all data to $outputdir"

trap kill_collection INT

date "+%Y-%m-%d %H:%M:%S" > ${outputdir}/collection_start

## PUT ALL THE NECESSARY TESTS IN HERE

if [ "$ISRDS" == "false" ]; then
    mpstat 1 -I SUM -u | gzip >> ${outputdir}/mpstat.mdbs & # This will also provide intr/s removed in 2014.
    vmstat 1 | gzip >> ${outputdir}/vmstat.mdbs &
    iostat -mx 1 | gzip >> ${outputdir}/iostat.mdbs &
fi

mariadb-admin ${MARIADB_OPTIONS} ext -i1 | gzip >> ${outputdir}/mariadb-admin.mdbs &

function capture_innodb_metrics() {
  local interval=1
  while [ ! -f ${outputdir}/collection_stop ]
  do
    mariadb ${MARIADB_OPTIONS} -e "select name, subsystem, count, status from information_schema.INNODB_METRICS WHERE status='enabled'"
    echo "" 
    sleep ${interval}
  done
}
if [ "$MARIADBVERSION" -ge "56" ]; then
  capture_innodb_metrics | gzip >> $outputdir/innodb_metrics.mdbs &
fi

function capture_innodb_status () {
  interval=60

  while [ ! -f ${outputdir}/collection_stop ]
  do
    mariadb ${MARIADB_OPTIONS} -e "show engine innodb status\G"
    sleep ${interval}
  done
}
capture_innodb_status | gzip >> $outputdir/innodb_status.mdbs &

function capture_processlist () {
  interval=60

  while [ ! -f ${outputdir}/collection_stop ]
  do
    echo "#TS $(date '+%Y-%m-%d_%H-%M-%S')"; 
    mariadb ${MARIADB_OPTIONS} -e "show full processlist\G";
    sleep ${interval}
  done
}
if [ "$COLLECTPROCESSLIST" != "" ]; then
  capture_processlist | gzip >> $outputdir/processlist.mdbs &
fi

function capture_innodb_mutex () {
  interval=60

  while [ ! -f ${outputdir}/collection_stop ]
  do
    echo "#TS $(date '+%Y-%m-%d_%H-%M-%S')"; 
    mariadb ${MARIADB_OPTIONS} -e "show engine innodb mutex";
    sleep ${interval}
  done
}
if [ "$COLLECTINNODBMUTEX" != "" ]; then
  capture_innodb_mutex | gzip >> $outputdir/innodb_mutex.mdbs &
fi

function capture_slave_status () {
  interval=1

  mariadb ${MARIADB_OPTIONS} -e "show slave status"
  sleep ${interval}

  while [ ! -f ${outputdir}/collection_stop ]
  do
    mariadb ${MARIADB_OPTIONS} --skip-column-names -e "show slave status"
    sleep ${interval}
  done
}
if [ $COLLECTSLAVESTATUS = true ]; then
  capture_slave_status | gzip >> $outputdir/slave_status.mdbs &
fi

function capture_aws_aurora () {
  interval=1

  mariadb ${MARIADB_OPTIONS} -e "select * from INFORMATION_SCHEMA.REPLICA_HOST_STATUS"
  sleep ${interval}

  while [ ! -f ${outputdir}/collection_stop ]
  do
    mariadb ${MARIADB_OPTIONS} --skip-column-names -e "select * from INFORMATION_SCHEMA.REPLICA_HOST_STATUS"
    sleep ${interval}
  done
}
if [ $COLLECTAWSAURORA = true ]; then
  capture_aws_aurora | gzip >> $outputdir/aws_aurora.mdbs &
fi

function capture_global_variables () {
  interval=60

  while [ ! -f ${outputdir}/collection_stop ]
  do
    echo "#TS $(date '+%Y-%m-%d_%H-%M-%S')"; 
    mariadb ${MARIADB_OPTIONS} --skip-column-names -e "show global variables"
    sleep ${interval}
  done
}
if [ $COLLECTVARIABLES = true ]; then
  capture_global_variables | gzip >> $outputdir/global_variables.mdbs &
fi

function collect_diskstats {
  local INTERVAL=1
  while true; do
     sleep=$(date +%s.%N | awk "{print $INTERVAL - (\$1 % $INTERVAL)}")
     sleep $sleep
     date +"TS %s.%N %F %T"
     cat /proc/diskstats
  done  
}
if [ "$ISRDS" == "false" ]; then
    collect_diskstats | gzip >> ${outputdir}/diskstats.mdbs &
fi

function capture_tokudb_status () {
  local interval=1

  while [ ! -f ${outputdir}/collection_stop ]
  do
    echo "#TS $(date '+%Y-%m-%d_%H-%M-%S')"; 
    mariadb ${MARIADB_OPTIONS} -e "show engine tokudb status";
    sleep ${interval}
  done
}
if [ $COLLECTTOKUDB == true ]; then
  capture_tokudb_status | gzip >> $outputdir/tokudb_status.mdbs &
fi

function capture_meminfo () {
  local interval=1

  while [ ! -f ${outputdir}/collection_stop ]
  do
    [ -f /proc/meminfo ] && (echo "#TS $(date '+%Y-%m-%d_%H-%M-%S')"; cat /proc/meminfo )
    sleep ${interval}
  done
}
if [ "$COLLECTMEMINFO" != "" ]; then
  capture_meminfo | gzip >> $outputdir/meminfo.mdbs &
fi

function capture_mountstats () {
  local interval=1

  while [ ! -f ${outputdir}/collection_stop ]
  do
    [ -f /proc/self/mountstats ] && (echo "#TS $(date '+%Y-%m-%d_%H-%M-%S')"; cat /proc/self/mountstats )
    sleep ${interval}
  done
}
if [ "$COLLECTMOUNTSTATS" != "" ]; then
  capture_mountstats | gzip >> $outputdir/mountstats.mdbs &
fi

# get all bg jobs to kill
for i in $(jobs -p )
do 
  bg_jobs+=("$i")
done

################################


if [ "$duration" == "ctrlc" ]; then
  
  while true; 
  do
    check_disk_space
    sleep 60;
  done

else
  counter=0
  while [ "$counter" -le "$duration" ]; 
  do
    check_disk_space
    counter=$(($counter+1))
    sleep 60
  done
fi

kill_collection

} ## end audit_metrics

# ###########################################################################
# End audit_metrics
# ###########################################################################

# ###########################################################################
# audit_environment package
# ###########################################################################

function audit_environment(){

   # if [ -z "${OPT_DEBUG}" ]; then
   #    echo "audit_environment is not yet implemented. Continuing..."
   #    return
   # fi


   if [ -n "${OPT_HOST}" ] && [ -n "${OPT_PORT}" ] && [ -n "${OPT_PASSWORD}" ] && [ -n "${OPT_USER}" ]; then
      local MARIADB_OPTIONS="-h ${OPT_HOST} -P ${OPT_PORT} -p${OPT_PASSWORD} -u ${OPT_USER}"
   elif [ -n "${OPT_SOCKET}" ] && [ -n "${OPT_USER}" ] && [ -n "${OPT_PASSWORD}" ]; then
      local MARIADB_OPTIONS="-u ${OPT_USER} -S ${OPT_SOCKET} -p${OPT_PASSWORD}"
   elif [ -n "${OPT_DEFAULTS_FILE}" ]; then
      local MARIADB_OPTIONS="--defaults-file=${OPT_DEFAULTS_FILE}"
   else
      local MARIADB_OPTIONS=${MARIADB_OPTIONS:-${OPT_MARIADB_OPTIONS:-""}}
   fi

   ### Configs
   pt_file_path=`which mariadb-summary`

   # if there are many tables on the server that could cause problems for the script
   number_of_tables="${OPT_SUPPORT_LIMIT:-10000}" # original: -n
   mariadb_options="${MARIADB_OPTIONS}" # original: -o
   out_dir="${OPT_SUPPORT_OUTPUT_DIR:-`pwd`}/`hostname`_${OPT_SUPPORT_ANNOTATION:-""}environment_`date +%F`" # original: -d or -i
   ISRDS=${OPT_SUPPORT_SKY:-""} # original: -i
   PIDTOUSE=${OPT_SUPPORT_PID:-$$} # original: -p
   ## The original script was a negative on this, original: -t
   TARRESULT=${OPT_SUPPORT_TAR_RESULT:-"yes"}
   SKIPROOTCHECK=${OPT_SUPPORT_NOT_ROOT:-""} # original: -r

   function usage {
      echo ""
      echo "You've hit a bug! Please contact our JIRA board to help us patch this issue for you!"
      echo "https://jira.mariadb.org/projects/TOOLS (be sure to sanitize any relevant personal data!)"
      echo ""
   }

       

   ### NON CONFIGS

   options="--table"
   options="-B"

   ### Functions

   # We used to download tools if we cannot find it, but....that would be really awkward...
   function check_mdb_tools {
      return; # No, I don't think I will....
   #   mdb_directory=`find  . -maxdepth 1 -iname "$pt_file_path*" -type d`
   #   if ! test -d "./$mdb_directory" -a "$mdb_directory" != ""
   #   then
   #      echo "Downloading mariadb-tools, Check https://mariadb.com/downloads/tools/server-tools/ for more details"
   #      if check_binary wget; then
   #         wget -o pt.dl.log "https://dlm.mariadb.com/1869520/mariadb-tools/6.0.0-rc1/mariadb-tools-6.0.0rc.tar.gz" -O ${pt_file_path}.tar.gz
   #      else
   #         echo "Using curl to download MariaDB Tools"
   #         curl --connect-timeout 5 -L -o mariadb-tools.tar.gz https://dlm.mariadb.com/1869520/mariadb-tools/6.0.0-rc1/mariadb-tools-6.0.0rc.tar.gz
   #      fi
   #      tar -xzf ./$pt_file_path.tar.gz >> mdbt.dl.log 2>> mdbt.dl.log || true
   #      mdb_directory=`find  . -maxdepth 1 -iname "$pt_file_path*" -type d`
   #   fi
   #   if ! test -f "./mariadb-summary"
   #   then
   #     echo "Can't download mariadb-tools, please manually download from https://mariadb.com/downloads/tools/server-tools/ and untar"
   #     exit 1
   #   fi
   }

   # Try to run a query and print error if it fails.
   function check_mariadb_connection {
     if [ "`mariadb $mariadb_options -NBe 'select 1'`" != "1" ] 
     then
       echo "Can't connect to local mariadb. Please add connection information to ~/.mariadb.cnf"
       echo "Example: "
       echo "[client]"
       echo "user=mariadb"
       echo "password=s3cret"
       echo "# If RDS, add host="
       echo ""
       exit 1
     fi
   }

   # Print error if specified binary i not found.
   # @param  Binary.
   # Example:
   # check_binary numactl
   function check_binary() {
     binary=$1
     which $binary &> /dev/null
     if [ "$?" != "0" ]; then
       echo -e "\nWARNING: Could not find $binary or it is not executable"
       return 1
     else 
       return 0
     fi
   }

   # Check if there are many tables on the server.
   # check_numbers = !(tables in server > $number_of_tables)
   function check_number_of_tables() {
     ddir=$(mariadb $mariadb_options -BN -e "show variables like 'datadir'" | awk '{print $2}')
     table_num=`find $ddir -type f -name "*.frm" | egrep -v "/mariadb/mariadb/" | wc -l`

     if [ "$table_num" -gt "$number_of_tables" ]; then
       check_numbers=false
       echo $table_num > "$out_dir"/number_of_tables
     else
       check_numbers=true
     fi
   }

   # Execute an SQL string and write output into a text file
   # @param  description, printed to stdout
   # @param  sql query
   # @param  new file name
   # Example:
   # sql_to_file 'Useless list of collations' 'SHOW COLLATIONS' 'collations'
   function sql_to_file() {
     stat_desc=$1
     stat_query=$2
     stat_file=$3
     
     echo " - "$stat_desc
     echo "-----$stat_query=====" > "$out_dir/"$stat_file
     mariadb $mariadb_options $options -e "$stat_query" | mariadb-align-output 2> /dev/null 1>> "$out_dir/"$stat_file
     gzip "$out_dir/"$stat_file 2>/dev/null 1>> "$out_dir/"$stat_file.mdbs
   }



   ### Main

   # Don't need to be root if RDS
   if [ "${ISRDS}" == false -a `whoami` != 'root' -a ! "${SKIPROOTCHECK}" ]
   then
       echo "ERROR: $0 must be run by root"
       exit 1
   fi

   if [ `whoami` != 'root' -a "${SKIPROOTCHECK}" ]
   then
     RUNASROOT='false'
   else
     RUNASROOT='true'
   fi

   set -ue

   check_mariadb_connection

   # check if all tools are available
   check_mdb_tools

   # get some MariaDB variables we'll need
   variables_datadir=`mariadb $mariadb_options -NBe "SELECT @@global.datadir;"`
   variables_log_error=`mariadb $mariadb_options -NBe "SELECT @@global.log_error;"`
   variables_innodb_open_files=`mariadb $mariadb_options -NBe "SELECT @@global.innodb_open_files;"`
   variables_open_files_limit=`mariadb $mariadb_options -NBe "SELECT @@global.open_files_limit;"`
   variables_innodb_stats_on_metadata=`mariadb $mariadb_options -NBe "SELECT @@global.innodb_stats_on_metadata;"`

   # Try to set innodb_stats_on_metadata=0. If we fail, abort the script.
   old_stats_on_meta=$variables_innodb_stats_on_metadata
   if [ $old_stats_on_meta -ne 0 ]
   then
     echo "!!! We will set global innodb_stats_on_metadata = 0. "
     echo "!!! If absolutely necessary, please set it back with mariadb -e 'set global innodb_stats_on_metadata = 1'"
     message=$(`mariadb $mariadb_options -e 'set global innodb_stats_on_metadata = 0'` 2>&1)

     # check if SET succeeded (do we have SUPER?)
     if [ $? -ne 0 ]; then
       echo $message
       echo 'Could not set innodb_stats_on_metadata. Executing this script without this change would be dangerous. Stopping'
       exit 1
     fi
   fi

   # If innodb_open_files > open_files_limit abort.
   # More info: https://jira.mariadb.org/browse/MDEV-14325 , https://jira.mariadb.org/browse/MDEV-14239
   if [ $variables_innodb_open_files -gt $variables_open_files_limit ]; then
     echo "innodb_open_files > open_files_limit. They are, respectively $variables_innodb_open_files and $variables_open_files_limit."
     echo 'This can cause a crash. Fix the problem before running this script'
     echo 'For more information as to this issue, please see:'
     echo 'https://jira.mariadb.org/browse/MDEV-14325 , https://jira.mariadb.org/browse/MDEV-14239'
     exit 1
   fi

   if [ $ISRDS == false ]; then
     # More than 1 mariadbd running?
     # If so, you'll need to manually specify the PID
     set +e
     pids=($(pidof mariadbd))
     set -e
     numPids=${#pids[@]}

     if [ "$numPids" -eq "1" ]; then
       PIDTOUSE=${pids[0]}
     elif [[ "$numPids" -gt "1" && ! "${PIDTOUSE+defined}" ]]; then
       echo "Problem:"
       echo " Found ${#pids[@]} (${pids[@]}) pids for MariaDB. Are there multiple instances of MariaDB running?"
       echo " You need to specify which PID to use by passing '-p <pid>'"
       exit 1
     elif [ "$numPids" -lt "1" ]; then
       echo "Problem:"
       echo "Could not find a MariaDB Pid. Maybe you want to collect an RDS instance? Try using '-i'"
       exit 1
     fi
   fi

   # Script Body
   # ===========
   #
   # Checks that may prevent the scipt execution must happen before this point.
   # So no unnecessary dirs/files will be created.

   mkdir -p "$out_dir"

   if [ $ISRDS == false ]; then
     check_number_of_tables
   else
     check_numbers=true
   fi

   #####
   # let's ignore eventual errors and keep collecting
   set +e

   #############################
   # System config

   if [ $ISRDS == false ]; then
     echo -n "Collecting system info... "
     
     cat /proc/cpuinfo > "$out_dir"/cpuinfo
     cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor > "$out_dir"/scaling_governor
     cpupower frequency-info > "$out_dir"/cpupower_frequency-info 2>&1
     cat /proc/meminfo > "$out_dir"/meminfo
     cat /proc/sys/vm/swappiness  > "$out_dir"/swappiness
     if check_binary dmidecode;then
       test "$RUNASROOT" == 'true' && dmidecode > "$out_dir"/dmidecode || true
     fi
     sysctl -a > "$out_dir"/sysctl || true
     mariadb-system-summary > "$out_dir"/mariadb-summary
     dmesg > "$out_dir"/dmesg

     # LVM 
     if [ "$RUNASROOT" == 'true' ]; then
       if check_binary lvdisplay;then
         lvdisplay > "$out_dir"/lvdisplay
         lvdisplay -vm > "$out_dir"/lvdisplay_vm
       fi
       if check_binary vgdisplay;then
         vgdisplay > "$out_dir"/vgdisplay
       fi
       if check_binary pvdisplay;then
         pvdisplay > "$out_dir"/pvdisplay
       fi
       if check_binary lvs;then
         lvs --segments > "$out_dir"/lvdisplay_segments
       fi
     fi
     # If LVM is being used, but not run as root, we can get the dm-* numbers
     # by looking at /dev/mapper device numbers.
     # This is useful when looking at the PCS graphs and trying to match DM disks
     # with mounted filesystems.
     test -d /dev/mapper && ls -alhs /dev/mapper/ > "$out_dir"/dev_mapper
     
     if check_binary lspci;then
       lspci > "$out_dir"/lspci
     fi
     if check_binary ip;then
       ip addr > "$out_dir"/ip
     fi
     if check_binary ifconfig;then
       ifconfig > "$out_dir"/ifconfig
     fi
     if check_binary netstat;then
       netstat -s > "$out_dir"/netstat
     fi
     if check_binary route;then
       route -n > "$out_dir"/route
     fi
     # get full options of mounted fs
     cat /proc/mounts > "$out_dir"/mounts

     # get info related to NUMA
     if check_binary numactl; then
       numactl --hardware > "$out_dir"/numa
       numactl --show >> "$out_dir"/numa
     fi
     if check_binary numastat; then
       numastat -m > "$out_dir"/numa_stat
     fi
     
     # lscpu can also provide us numa info
     if check_binary lscpu; then
       lscpu > "$out_dir"/lscpu
     fi

     # get info related to memory and disk
     free -m > "$out_dir"/free
     df -h > "$out_dir"/df
     
     # get all info related to datadir
     filename=$variables_datadir
     echo $filename > "$out_dir"/datadir
     cat /proc/mounts | grep " $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') " | tail -n 1 >> "$out_dir"/datadir
     datadisk=$(readlink -f $(cat /proc/mounts | grep " $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') " | tail -n 1 | cut -d' ' -f1))
     echo $datadisk >> "$out_dir"/datadir
     df -P -h $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') | tail -n 1 >> "$out_dir"/datadir
     du -sh $filename >> "$out_dir"/datadir
     if echo $datadisk | grep 'dm-' >/dev/null 2>&1
     then
       pvs | grep $(lvdisplay | awk '/LV Name/{n=$3} /VG Name/{v=$3} /Block device/{d=$3; sub(".*:","dm-",d); print d,n,v;}' | grep ${datadisk/\/dev\//} | awk '{print $3}') | awk '{print $1}'i >> "$out_dir"/datadir
     else
       echo ${datadisk/[0-9]*/} >> "$out_dir"/datadir
     fi
     
     # get all info related to tmpdir
     filename=$(mariadb $mariadb_options -BN -e "show variables like 'tmpdir'" | awk '{print $2}')
     echo $filename > "$out_dir"/tmpdir
     cat /proc/mounts | grep " $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') " | tail -n 1 >> "$out_dir"/tmpdir
     if [[ "x$(cat /proc/mounts | grep " $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') " | tail -n 1 | cut -d' ' -f1)" == "xtmpfs" ]] 
     then  
       df -P -h | grep tmpfs | grep $filename>> "$out_dir"/tmpdir
     else
       datadisk=$(readlink -f $(cat /proc/mounts | grep " $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') " | tail -n 1 | cut -d' ' -f1))
       echo $datadisk >> "$out_dir"/tmpdir
       df -P -h $(df -P "$filename" | awk 'NR==1 {next} {print $6; exit}') | tail -n 1 >> "$out_dir"/tmpdir
       du -sh $filename >> "$out_dir"/tmpdir
       if echo $datadisk | grep 'dm-' >/dev/null 2>&1
       then
         pvs | grep $(lvdisplay | awk '/LV Name/{n=$3} /VG Name/{v=$3} /Block device/{d=$3; sub(".*:","dm-",d); print d,n,v;}' | grep ${datadisk/\/dev\//} | awk '{print $3}') | awk '{print $1}'i >> "$out_dir"/tmpdir
       fi
     fi

     # collecting cron jobs only from crontab and from /etc/cron.d/
     find /var/spool/cron/ -type f -print -exec cat {} \; > "$out_dir"/crontab_spool_users
     find /etc/cron.d/ -type f -print -exec cat {} \; > "$out_dir"/crontab_crond
     cat /etc/crontab > "$out_dir"/crontab_etc

     # get oom_score_adj
     [ -f /proc/${PIDTOUSE}/oom_score_adj ] && cat /proc/${PIDTOUSE}/oom_score_adj > "$out_dir"/oom_score_adj

     echo "Done."
   else
     echo "Environment is RDS. Not collecting system info."
   fi

   #############################
   ## MariaDB config
   echo -n "Executing mariadb-database-summary...with options: $mariadb_options"
   mariadb-database-summary -- $mariadb_options > "$out_dir"/mariadb-database-summary
   echo "Done"

   ##
   echo -n "Collecting MariaDB config info... "

   # innodb_stats_on_metadata old value
   echo "$old_stats_on_meta" > "$out_dir/default_metadata_value"

   mariadb $mariadb_options -NBe 'SELECT NOW()' > "$out_dir/mariadb_collect_start"
   mariadb $mariadb_options -NBe "SHOW GLOBAL VARIABLES" > "$out_dir/mariadb_variables"
   mariadb $mariadb_options -NBe "SHOW GLOBAL STATUS" > "$out_dir/mariadb_global_status"
   mariadb $mariadb_options -NBe "SHOW ENGINE INNODB STATUS\G" > "$out_dir/mariadb_innodb_status"

   # RDS Doesn't Grant SUPER nor REPLICATION CLIENT privs
   if [ $ISRDS == false ]; then
     mariadb $mariadb_options $options -Be "SHOW SLAVE STATUS\G" > "$out_dir/mariadb_slave_status"
     mariadb $mariadb_options $options -Be "SHOW MASTER STATUS\G" > "$out_dir/mariadb_master_status"
   fi

   if [ $ISRDS == false ]; then
     touch "$out_dir/cmdline"
     ps -A | grep "mariadbd" | awk '{print $1}' |
     while read pid; do
       echo `cat /proc/$pid/cmdline` | sed 's/--/ --/' >> "$out_dir/cmdline"
     done
   fi

   # check_tmp_dir and mariadb.cnf if not RDS
   if [ $ISRDS == false ]; then
     if check_binary "lsof";then
       lsof -p ${PIDTOUSE} | grep del > "$out_dir/tmpdir_lsof"
     fi
     MARIADB_CNF=""
     test -f "/etc/mysql/mariadb.cnf" && MARIADB_CNF="/etc/mysql/mariadb.cnf"
     test -f "/etc/mysql/mysql.cnf" && MARIADB_CNF="/etc/mysql/mysql.cnf"
     if ! test -z "$MARIADB_CNF"
     then
       mariadb-config-diff $mariadb_options localhost $MARIADB_CNF > "$out_dir"/mariadb-config-diff
       cp $MARIADB_CNF "$out_dir"/my.dot.cnf
       
       # Look for any sinlgular included files
       for i in `grep "^\!include " $MARIADB_CNF | awk '{print $2}'`; do
         f=$i
         if [ "${i}" == "`basename ${i}`" ]; then
           f="`dirname ${MARIADB_CNF}`/${i}"
         fi
         cp $f "$out_dir"/my.dot.cnf_`basename ${f}`
       done
       
       # Look for any included directories
       for i in `grep "^\!includedir " $MARIADB_CNF | awk '{print $2}'`; do
         if test -d $i; then
           for i in `find $i -type f -print`; do
             cp $i "$out_dir"/my.dot.cnf_`basename ${i}`
           done
         fi
       done
     else
       echo "Neither /etc/mariadb.cnf nor /etc/mariadb/mariadb.cnf exists" > "$out_dir"/mariadb-config-diff
     fi
   fi

   echo "Done."

   #############################
   if [ $ISRDS == false ]; then
     echo -n "Collecting Error Log... "
     error_log="$variables_log_error"
     if test -f "$error_log" ; then
       tail -n 1000 "$error_log" > "$out_dir/error_log"
     fi
     echo "Done."
   fi

   #############################
   if [ "$check_numbers" = "true" ]; then
     echo -n "Collecting MariaDB Schema... "
     mariadb-dump $mariadb_options -f --no-data --triggers --routines --set-charset --all-databases --lock-tables=false > "$out_dir/mariadb_schema"
     echo "Done."
   else
     echo "There are many tables on the server, so we skipped the schema collection that might can cause problems."
   fi

   #############################
   if [ "$check_numbers" = "true" ]; then
     echo -n "Running mariadb-index-checker, this may take a while... "
     mariadb-index-checker $mariadb_options  > "$out_dir/mariadb-index-checker"
     echo "Done."
   else
     echo "There are many tables on the server, so we skipped mariadb-index-checker."
   fi

   # get MariaDB flavor
   DBMS_NAME=`mariadb $mariadb_options $options --skip-column-names -e "SELECT IF(@@global.version_comment LIKE '%mariadb%', 'MariaDB', IF(@@global.version_comment LIKE '%percona%', 'Percona Server', 'MariaDB'));"`

   #############################
   if [ "${ISRDS}" == false -a ! -z $variables_datadir ]; then
     echo -n "Collecting MariaDB usage info (datadir = $variables_datadir)... "
     du -sh "$variables_datadir" >> "$out_dir/data_usage_raw"
     find "$variables_datadir" -name "*.ibd" -or -name "ibdata*" | xargs du -shc  | tail -1 > "$out_dir/data_usage_innodb_raw"
     # MyISAM
     find "$variables_datadir" -name "*.MYD" | xargs du -shc  | tail -1 > "$out_dir/data_usage_myisam_data_raw"
     find "$variables_datadir" -name "*.MYI" | xargs du -shc  | tail -1 >> "$out_dir/data_usage_myisam_index_raw"
     # Aria
     if [ "$DBMS_NAME" = "MariaDB" ]; then
       find "$variables_datadir" -name "*.MAD" | xargs du -shc  | tail -1 > "$out_dir/data_usage_aria_data_raw"
       find "$variables_datadir" -name "*.MAI" | xargs du -shc  | tail -1 >> "$out_dir/data_usage_aria_index_raw"
     fi
     echo "Done."
   else
     echo "Can't find the MariaDB datadir or is RDS; Will skip collection data info."
   fi

   #############################
   echo "Collecting MariaDB table and engine info... "

   ## get mariadb version
   MAJOR_VERSION=`mariadb $mariadb_options $options --skip-column-names -e "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(VERSION(), '-', 1), '.', 1);"`
   MINOR_VERSION=`mariadb $mariadb_options $options --skip-column-names -e "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(VERSION(), '-', 1), '.', 2), '.', -1);"`

   ## set query items that depend on MariaDB version/flavor
   if [ "$MINOR_VERSION" = "7" ]; then
     PASSWORD_COLUMN="authentication_string"
   else
     PASSWORD_COLUMN="password"
   fi

   ## plugins 
   sql_to_file 'SHOW PLUGINS' 'SHOW PLUGINS' 'plugins'

   ## engines
   sql_to_file 'SHOW ENGINES' 'SHOW ENGINES' 'engines'

   if [ "$check_numbers" = "true" ]; then
     ## overall dataset size
     sql="
     SELECT CONCAT(ROUND(SUM(data_length) / (1024*1024*1024),2),'G') Data_Size,
       CONCAT(ROUND(SUM(index_length)/ (1024*1024*1024),2),'G') Index_Size,
       CONCAT(ROUND((sum(data_length)+sum(index_length))/(1024*1024*1024), 2),'G') Total_Size
     FROM information_schema.TABLES
     WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'sys')
     GROUP BY NULL
     "
     sql_to_file 'Overall Dataset Size' "$sql" 'dataset'

     ## storage engine usage
     sql="
     SELECT ENGINE AS Storage_Engine, COUNT(*) Tables_Count,
       CONCAT(ROUND(SUM(data_length) / (1024*1024*1024),2),'G') Data_Size,
       CONCAT(ROUND(SUM(index_length)/ (1024*1024*1024),2),'G') Index_Size,
       CONCAT(ROUND((sum(data_length)+sum(index_length))/(1024*1024*1024), 2),'G') Total_Size
     FROM information_schema.TABLES
     WHERE ENGINE IS NOT NULL
       AND table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
     GROUP BY ENGINE WITH ROLLUP;
     "
     sql_to_file 'Storage Engine Usage' "$sql" 'engine_usage'

     ## top 10 largest tables
     sql="
     SELECT CONCAT(table_schema, '.', table_name) as Schema_Table, ENGINE AS Storage_Engine,
       CONCAT(ROUND(table_rows/1000000,2),'M') Rows_Count,
       CONCAT(ROUND(data_length/(1024*1024*1024),2),'G') Data_Size,
       CONCAT(ROUND(index_length/(1024*1024*1024 ),2),'G') Index_Size,
       CONCAT(ROUND(( data_length+index_length)/(1024*1024*1024),2),'G') Total_Size,
       ROUND(index_length / data_length, 2) Index_Fraction
     FROM information_schema.TABLES
     WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'sys')
     ORDER BY data_length + index_length DESC LIMIT 10;
     "
     sql_to_file 'Top 10 Tables' "$sql" 'top10_large_tables'

     ## MyISAM table sizes
     sql="
     SELECT table_schema, table_name, table_rows, 
       CONCAT(ROUND((index_length+data_length)/1024/1024),'MB') AS total_size  
     FROM information_schema.TABLES    
     WHERE engine='myisam' AND table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys');
     "
     sql_to_file 'MyISAM Data/Index Usage' "$sql" 'mariadb_myisam_tables'

     ## Aria table sizes
     if [ "$DBMS_NAME" = "MariaDB" ]; then
       sql="
       SELECT table_schema, table_name, table_rows as rows_count, 
         CONCAT(ROUND((index_length+data_length)/1024/1024),'MB') AS total_size  
       FROM information_schema.TABLES    
       WHERE engine='aria' AND table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys');
       "
       sql_to_file 'Aria Data/Index Usage' "$sql" 'mariadb_aria_tables'
     fi

     ## fulltext index info
     sql="
      SELECT S.table_schema, S.table_name, S.column_name, T.ENGINE AS storage_engine
      FROM information_schema.STATISTICS S
      JOIN information_schema.TABLES T ON S.TABLE_SCHEMA=T.TABLE_SCHEMA
        AND S.TABLE_NAME = T.TABLE_NAME
      WHERE index_type = 'FULLTEXT'
        AND S.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys');
     "
     sql_to_file 'FULLTEXT index statistics' "$sql" 'mariadb_full_text'

     ## per-engine data usage
     sql="
     SELECT COUNT(*) AS Tables_Count, 
       CONCAT(ROUND(SUM(data_length) / ( 1024 * 1024 * 1024 ), 2), 'G') Data_Size, 
       CONCAT(ROUND(SUM(index_length) / ( 1024 * 1024 * 1024 ), 2), 'G') Index_Size,   
       CONCAT(SUM(ROUND(( data_length + index_length ) / 
       ( 1024 * 1024 * 1024 ), 2)), 'G') Total_Size, engine AS Storage_Engine 
     FROM information_schema.TABLES 
     WHERE TABLE_SCHEMA NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
     GROUP BY engine;
     "
     sql_to_file 'Data/Index Usage By Engine' "$sql" 'data_usage_by_storage_engine'

     ## top 100 table usage
     sql="
     SELECT CONCAT(table_schema, '.', table_name) Schema_Table,
       CONCAT(ROUND(table_rows / 1000000, 2), 'M') Rows_Count,
       CONCAT(ROUND(data_length / ( 1024 * 1024 * 1024 ), 2), 'G') Data_Size,
       CONCAT(ROUND(index_length / ( 1024 * 1024 * 1024 ), 2), 'G') Index_Size,
       CONCAT(ROUND(( data_length + index_length ) / ( 1024 * 1024 * 1024 ), 2), 'G') Total_Size,
       ROUND(index_length / data_length, 2) Index_Fraction
     FROM  information_schema.TABLES
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND TABLE_TYPE <> 'VIEW' 
     ORDER BY data_length + index_length DESC LIMIT 100
     "
     sql_to_file 'Data/Index Usage By Table, Top 100' "$sql" 'data_usage_by_table'

     ## per-schema usage
     sql="
     SELECT table_schema, 
       ROUND(SUM(data_length+index_length)/1024/1024/1024, 2) as Total_Size_GB, 
       ROUND(SUM(data_length)/1024/1024/1024,2) as Data_Size_GB, 
       ROUND(SUM(index_length)/1024/1024/1024,2) as Index_Size_GB 
     FROM information_schema.tables 
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND TABLE_TYPE <> 'VIEW'
     GROUP BY 1 ORDER BY 2 DESC
     "
     sql_to_file 'Data/Index Usage By Schema' "$sql" 'data_usage_by_schema'

     ## MyISAM data usage
     sql="
     SELECT CONCAT(table_schema, '.', table_name) Schema_Table,
       CONCAT(ROUND(table_rows / 1000000, 2), 'M') Rows_Count,
       CONCAT(ROUND(data_length / ( 1024 * 1024 * 1024 ), 2), 'G') Data_Size,
       CONCAT(ROUND(index_length / ( 1024 * 1024 * 1024 ), 2), 'G') Index_Size,
       CONCAT(ROUND(( data_length + index_length ) / ( 1024 * 1024 * 1024 ), 2), 'G') Total_Size,
       ROUND(index_length / data_length, 2) Index_Fraction
     FROM information_schema.TABLES
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND TABLE_TYPE <> 'VIEW' AND engine='MyISAM'
     ORDER BY data_length + index_length DESC LIMIT 100
     "
     sql_to_file 'Data/Index Usage of MyISAM' "$sql" 'data_usage_by_myisam_tables'

     if [ "$DBMS_NAME" = "MariaDB" ]; then
       ## Aria data usage
       sql="
       SELECT CONCAT(table_schema, '.', table_name) Schema_Table,
         CONCAT(ROUND(table_rows / 1000000, 2), 'M') Rows_Count,
         CONCAT(ROUND(data_length / ( 1024 * 1024 * 1024 ), 2), 'G') Data_Size,
         CONCAT(ROUND(index_length / ( 1024 * 1024 * 1024 ), 2), 'G') Index_Size,
         CONCAT(ROUND(( data_length + index_length ) / ( 1024 * 1024 * 1024 ), 2), 'G') Total_Size,
         ROUND(index_length / data_length, 2) Index_Fraction
       FROM information_schema.TABLES
       WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
         AND TABLE_TYPE <> 'VIEW' AND engine='Aria'
       ORDER BY data_length + index_length DESC LIMIT 100
       "
       sql_to_file 'Data/Index Usage of Aria' "$sql" 'data_usage_by_aria_tables'
     fi

     ## partition info
     sql="
     SELECT COUNT(*) AS PARTS_COUNT, TABLE_SCHEMA, TABLE_NAME, PARTITION_EXPRESSION
     FROM information_schema.PARTITIONS
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
     GROUP BY TABLE_SCHEMA, TABLE_NAME, PARTITION_EXPRESSION HAVING COUNT(*) > 1;
     "
     sql_to_file 'Tables with Partitions' "$sql" 'tables_with_partitions'

     ## More partitions
     sql="
     SELECT TABLE_SCHEMA, TABLE_NAME, PARTITION_METHOD, PARTITION_EXPRESSION, SUM(TABLE_ROWS) TABLE_ROWS
     FROM information_schema.partitions 
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND PARTITION_METHOD IS NOT NULL 
     GROUP BY TABLE_SCHEMA, TABLE_NAME, PARTITION_METHOD, PARTITION_EXPRESSION;
     "
     sql_to_file 'Partition Statistics' "$sql" 'tables_with_partitioning'

     ## InnoDB compression info
     sql_to_file 'InnoDB Compressed Tables' "SELECT * FROM INFORMATION_SCHEMA.INNODB_CMP;" 'tables_innodb_compression'

     ## InnoDB compression bp
     sql_to_file 'InnoDB Compressed Tables in Bufferpool' "SELECT * FROM INFORMATION_SCHEMA.INNODB_CMPMEM;" 'tables_with_compression_bp'

     ## InnoDB row formats
     sql="
     SELECT TABLE_SCHEMA, TABLE_NAME, ROW_FORMAT 
     FROM INFORMATION_SCHEMA.TABLES
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND ENGINE='InnoDB';
     "
     sql_to_file 'InnoDB Row Formats' "$sql" 'tables_innodb_format'

     ## Tables missing PK
     sql="
     SELECT tables.table_schema, tables.table_name, tables.table_rows
     FROM information_schema.tables
     LEFT JOIN (
       SELECT table_schema, table_name
       FROM information_schema.statistics
       GROUP BY table_schema, table_name, index_name
       HAVING
         SUM(
           CASE WHEN non_unique = 0 AND nullable != 'YES' THEN 1 ELSE 0 END
         ) = COUNT(*)
     ) puks
     ON tables.table_schema = puks.table_schema AND tables.table_name = puks.table_name
     WHERE puks.table_name IS NULL
       AND tables.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND tables.table_type = 'BASE TABLE' AND engine='InnoDB';
     "
     sql_to_file 'Tables Missing PK' "$sql" 'tables_without_primarykey'

     ## Multiple auto increments
     sql="
     SELECT CONCAT(a.table_schema,'.', a.TABLE_NAME) AS Table_Schema, SUM(a.table_rows) AS Rows_Count,
       CONCAT(ROUND((sum(a.index_length)+sum(a.data_length))/1024/1024),'MB') AS Table_Size,
       COUNT(b.COLUMN_NAME) AS Columns_In_Auto_Inc
     FROM information_schema.TABLES AS a
     JOIN information_schema.COLUMNS AS b ON b.TABLE_NAME = a.TABLE_NAME
       AND b.TABLE_SCHEMA = a.TABLE_SCHEMA
     WHERE engine = 'myisam'
       AND a.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND b.EXTRA='auto_increment'
     GROUP BY (1);
     "
     sql_to_file 'Tables with Multiple A_I' "$sql" 'mariadb_tables_with_multiple_autoinc'

     ## Non-optimal PK
     sql="
     SELECT a.TABLE_SCHEMA AS 'SCHEMA', a.TABLE_NAME,
       GROUP_CONCAT(a.COLUMN_NAME) AS 'COLUMN',
       GROUP_CONCAT(a.column_type) AS 'TYPE', SUM(b.TABLE_ROWS) AS table_rows
     FROM information_schema.COLUMNS AS a
     JOIN information_schema.TABLES AS b ON b.TABLE_NAME = a.TABLE_NAME
       AND b.TABLE_SCHEMA = a.TABLE_SCHEMA
     WHERE b.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND COLUMN_KEY='PRI'
       AND ENGINE IN ('InnoDB', 'TokuDB')
       AND 
       ( DATA_TYPE LIKE '%TEXT%'
         OR DATA_TYPE LIKE '%BLOB%'
         OR DATA_TYPE LIKE '%CHAR%'
         OR DATA_TYPE LIKE '%BINARY%' )
       AND TABLE_ROWS > 1000
     GROUP BY 1, 2;
     "
     sql_to_file 'Tables with non-optimal PK' "$sql" 'mariadb_tables_without_optimalPK'

     ## Tables in 5.5 time format
     version=$(mariadb $mariadb_options -BNe "show variables like 'version'" | awk {'print $2'} | cut -d'.' -f1-2)
     if [[ $version == "5.6" ]]; then
     echo " - Tables with 5.5 DATETIME format"
     sql="
     SELECT t.table_schema, t.engine, t.table_name, c.column_name, c.column_type
     FROM information_schema.tables AS t 
     INNER JOIN information_schema.columns AS c ON c.table_schema = t.table_schema 
       AND c.table_name = t.table_name
     LEFT OUTER JOIN information_schema.innodb_sys_tables AS ist 
       ON ist.name = concat(t.table_schema,'/',t.table_name)
     LEFT OUTER JOIN information_schema.innodb_sys_columns AS isc 
       ON isc.table_id = ist.table_id AND isc.name = c.column_name 
     WHERE c.column_type IN ('time','timestamp','datetime')
       AND t.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND t.table_type = 'base table'
       AND (t.engine = 'innodb' and isc.mtype = 6)
     ORDER BY t.table_schema, t.table_name, c.column_name;
     "
     sql_to_file 'Tables in 5.5 time format' "$sql" 'mariadb_tables_in_55_time_format'


     ## Sum tables with 5.5 and 5.6 DATETIME format
     sql="
     SELECT case isc.mtype when '6' then '5.5' when '3' then '5.6' end FORMAT, count(*) TOTAL
     FROM information_schema.tables AS t  
     INNER JOIN information_schema.columns AS c 
       ON c.table_schema = t.table_schema  AND c.table_name = t.table_name 
     LEFT OUTER JOIN information_schema.innodb_sys_tables AS ist  
       ON ist.name = concat(t.table_schema,'/',t.table_name) 
     LEFT OUTER JOIN information_schema.innodb_sys_columns AS isc  
       ON isc.table_id = ist.table_id AND isc.name = c.column_name  
     WHERE c.column_type IN ('time','timestamp','datetime') 
       AND t.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND t.table_type = 'base table' AND (t.engine = 'innodb' ) 
     GROUP BY isc.mtype;
     "
     sql_to_file 'Sum tables with 5.5 and 5.6 DATETIME format' "$sql" 'mariadb_tables_in_55_time_format_sum'
     fi

     ## AUTO_INCREMENT_FILL
     sql="
     SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, DATA_TYPE,
       COLUMN_TYPE, IF(LOCATE('unsigned', COLUMN_TYPE) > 0,1,0) AS IS_UNSIGNED,
       (
         CASE DATA_TYPE
           WHEN 'tinyint' THEN 255
           WHEN 'smallint' THEN 65535
           WHEN 'mediumint' THEN 16777215
           WHEN 'int' THEN 4294967295
           WHEN 'bigint' THEN 18446744073709551615
         END >> IF(LOCATE('unsigned', COLUMN_TYPE) > 0, 0, 1)
       ) AS MAX_VALUE,
       AUTO_INCREMENT, CONCAT(ROUND(
       AUTO_INCREMENT / (
         CASE DATA_TYPE
           WHEN 'tinyint' THEN 255
           WHEN 'smallint' THEN 65535
           WHEN 'mediumint' THEN 16777215
           WHEN 'int' THEN 4294967295
           WHEN 'bigint' THEN 18446744073709551615
         END >> IF(LOCATE('unsigned', COLUMN_TYPE) > 0, 0, 1)
       )*100),'%') AS AUTO_INCREMENT_RATIO
     FROM INFORMATION_SCHEMA.COLUMNS
       INNER JOIN INFORMATION_SCHEMA.TABLES USING (TABLE_SCHEMA, TABLE_NAME)
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND EXTRA='auto_increment' HAVING AUTO_INCREMENT_RATIO>60 ORDER BY CAST(AUTO_INCREMENT_RATIO AS SIGNED INTEGER) DESC LIMIT 10;  ;
     "
     sql_to_file 'Auto increment fill' "$sql" 'mariadb_autoincrement_fill'

     ## ROW FORMAT of InnoDB Tables with TEXT/BLOB
     sql="
     SET SESSION sql_mode = REPLACE(@@session.sql_mode, 'ONLY_FULL_GROUP_BY', '');
     SELECT CONCAT(t1.table_schema, '.', t1.table_name) as Schema_Table, ROW_FORMAT, count(*) as Total_TEXT_BLOB_Cols 
     FROM INFORMATION_SCHEMA.COLUMNS t1 
     JOIN INFORMATION_SCHEMA.TABLES t2 
     ON t2.TABLE_SCHEMA=t1.TABLE_SCHEMA AND t2.TABLE_NAME=t1.TABLE_NAME 
     WHERE t1.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND DATA_TYPE IN ('text','blob') AND ENGINE='InnoDB' 
     GROUP BY 1 ORDER BY 2 desc;
     "
     sql_to_file 'Row Format of InnoDB Tables with TEXT/BLOB columns' "$sql" 'mariadb_innodb_row_format_blob'

     ## Non-Local Root Accounts
     sql="
     SELECT user, host
     FROM mysql.user
     WHERE user = 'root' AND host != 'localhost' AND host != '127.0.0.1';
     "
     sql_to_file 'Non-Local Root Accounts' "$sql" 'non_local_root_accounts'

     ## Anonymous Accounts
     sql="
     SELECT user, host
     FROM mysql.user
     WHERE user = '';
     "
     sql_to_file 'Anonymous User Accounts' "$sql" 'anonymous_accounts'

     ## Accounts From Any Host
     sql="
     SELECT user
     FROM mysql.user
     WHERE host = '%' OR host = '' /*M!100005 AND is_role = 'N' */;
     "
     sql_to_file 'Accounts Accessible From Any Host' "$sql" 'accounts_from_any_host'

     ## Accounts with Identical Non-Empty passwords
     sql="
     SELECT GROUP_CONCAT(DISTINCT user) Users_With_Identical_Passwds, count(*) as Times_Passwd_Is_Used
     FROM mysql.user
     WHERE $PASSWORD_COLUMN != '' /*M!100005 AND is_role = 'N' */
     GROUP BY $PASSWORD_COLUMN HAVING COUNT($PASSWORD_COLUMN) > 1;
     "
     sql_to_file 'Accounts with Identical Non-Empty passwords' "$sql" 'accounts_with_identical_passwords'

     ## Non-Root All Privs
     numPrivs=`mariadb $mariadb_options $options -BNe "SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'mariadb' and table_name = 'user' and column_name LIKE '%_priv'"`
     privsString=`mariadb $mariadb_options $options -BNe "SELECT GROUP_CONCAT(column_name SEPARATOR ',') AS cols FROM information_schema.columns WHERE table_schema = 'mariadb' AND table_name = 'user' AND column_name LIKE '%_priv'"`
     sql="
     SELECT user
     FROM mysql.user
     WHERE user != 'root' AND CONCAT_WS('', ${privsString}) REGEXP 'Y\{${numPrivs}\}';
     "
     sql_to_file 'Non-Root Accounts with All Privileges' "$sql" 'non_root_all_privs'

     ## Non-Root with Admin Privs
     sql="
     SELECT user, host
     FROM mysql.user
     WHERE (Shutdown_Priv = 'Y' OR Super_Priv = 'Y' OR Reload_Priv = 'Y') AND user != 'root'
     "
     sql_to_file 'Non-Root Accounts with Admin Privileges' "$sql" 'non_root_admin_privs'

     ## Account with empty password
     sql="
     SELECT CONCAT(user, '@', host) AS User_Account
     FROM mysql.user
     WHERE $PASSWORD_COLUMN = '' /*M!100005 AND is_role = 'N' */;
     "
     sql_to_file 'Account with empty password' "$sql" 'account_empty_passwd'

     ##FILE_FORMAT and ROW_FORMAT
     sql="
     SELECT ROW_FORMAT, COUNT(*) Total_by_Format 
     FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES 
     GROUP BY ROW_FORMAT;
     "
     sql_to_file 'Row format of InnoDB Tables' "$sql" 'mariadb_innodb_file_format'

     ##FRAGMENTED/FREE SPACE in InnoDB TABLES
     sql="
     SELECT table_schema, table_name, CONCAT(ROUND((data_free / 1024 / 1024),2),'MB') data_free 
     FROM information_schema.tables 
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND ENGINE LIKE 'InnoDB' AND data_free > 100 * 1024 *  1024;
     "
     sql_to_file 'Fragmented/free space in InnoDB Tables (>100MB)' "$sql" 'mariadb_innodb_free_space'

     ##TABLES IN ibdata1
     sql="
     SELECT NAME 
     FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES 
     WHERE SPACE=0 AND NAME NOT LIKE 'SYS_%';
     "
     sql_to_file 'Tables in ibdata1 (table space 0)' "$sql" 'mariadb_innodb_ibdata'

     ##TABLE WITH BLOB/TEXT SIZE and PK and nb MUL
     sql="
     SET SESSION sql_mode = REPLACE(@@session.sql_mode, 'ONLY_FULL_GROUP_BY', '');
     SELECT CONCAT (TABLES.table_schema,'.', TABLES.table_name) as Table_Name,  
       CONCAT(ROUND(( data_length + index_length ) / ( 1024 * 1024 * 1024 ), 2), 'G') Total_Size,  
       CONCAT(ROUND(data_length / ( 1024 * 1024 * 1024 ), 2), 'G') Data_Size, 
       CONCAT(ROUND(index_length / ( 1024 * 1024 * 1024 ), 2), 'G') Index_Size, table_rows AS Total_Rows, 
       CONCAT(ROUND((data_free / 1024 / 1024),2),'M')  AS Data_Free,  
       GROUP_CONCAT(if(STRCMP(COLUMN_KEY,'PRI'),NULL,COLUMN_TYPE)) as  PK_Type , 
       SUM(if(STRCMP(COLUMN_KEY,'MUL'),0,1)) AS Secndry_Keys, 
       SUM(if(FIND_IN_SET(COLUMN_TYPE,'blob,longblog,mediumblob,text,longtext,mediumtext')>0,1,0)) AS BLOB_Cols 
     FROM information_schema.TABLES 
     JOIN information_schema.COLUMNS 
       ON COLUMNS.TABLE_NAME = TABLES.TABLE_NAME AND COLUMNS.TABLE_SCHEMA = TABLES.TABLE_SCHEMA 
     WHERE TABLES.table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND ENGINE LIKE 'InnoDB' GROUP BY 1,2 ORDER  BY 9 desc;
     "
     sql_to_file 'Tables Size with BloB, Text and PK and MUL' "$sql" 'mariadb_innodb_blobtext'


     ## Select Foreign Keys
     sql="
     SELECT CONSTRAINT_SCHEMA, CONSTRAINT_NAME, TABLE_SCHEMA, TABLE_NAME
     FROM information_schema.TABLE_CONSTRAINTS
     WHERE table_schema NOT IN ('mariadb', 'information_schema', 'performance_schema', 'sys')
       AND CONSTRAINT_TYPE= 'FOREIGN KEY';
     "
     sql_to_file 'Select Foreign Keys' "$sql" 'mariadb_foreign_keys'
    
     ## List all Triggers
     sql="
     SELECT TRIGGER_NAME, EVENT_MANIPULATION, EVENT_OBJECT_SCHEMA, EVENT_OBJECT_TABLE
     FROM information_schema.TRIGGERS
     ORDER BY EVENT_OBJECT_SCHEMA;
     "
     sql_to_file 'List Triggers' "$sql" 'mariadb_triggers'

     ## List all Procedures
     sql="
     SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE
     FROM information_schema.ROUTINES
     WHERE ROUTINE_TYPE = 'PROCEDURE'
     order by ROUTINE_SCHEMA;
     "
     sql_to_file 'List Procedures' "$sql" 'mariadb_procedures'

     ## List all Functions
     sql="
     SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE, DATA_TYPE
     FROM information_schema.ROUTINES
     WHERE ROUTINE_TYPE = 'FUNCTION'
     ORDER BY ROUTINE_SCHEMA;
     "
     sql_to_file 'List Functions' "$sql" 'mariadb_functions'

     ## List all Events
     sql="
     SELECT EVENT_SCHEMA, EVENT_NAME, DEFINER, EVENT_TYPE, LAST_EXECUTED, STATUS
     FROM information_schema.EVENTS
     ORDER BY EVENT_SCHEMA;
     "
     sql_to_file 'List Events' "$sql" 'mariadb_events'

   else

     echo "There are many tables on the server, we skipped the regular MariaDB collection queries because they might can cause problems."

   fi

   ##COLLECT PFS if enabled
   grep "performance_schema" $out_dir/mariadb_variables | grep ON
   if [[ $? == 0 ]]
   then
     echo "*** PFS is enabled ! ***"

     ## Accounts not properly closing connections
     sql="
     SELECT ess.user, ess.host, 
       (a.total_connections - a.current_connections) - ess.count_star as not_closed, 
       ((a.total_connections - a.current_connections) - ess.count_star) * 100 /
       (a.total_connections - a.current_connections) as pct_not_closed
     FROM performance_schema.events_statements_summary_by_account_by_event_name ess
     JOIN performance_schema.accounts a on (ess.user = a.user and ess.host = a.host)
     WHERE ess.event_name = 'statement/com/quit'
       AND (a.total_connections - a.current_connections) > ess.count_star;
     "
     sql_to_file 'Accounts not properly closing connections' "$sql" 'mariadb_pfs_account_not_properly_closing_connections'

     ## Hosts with errors in host_cache
     sql="
     SELECT IP, HOST, COUNT_HOST_BLOCKED_ERRORS
     FROM performance_schema.host_cache
     WHERE COUNT_HOST_BLOCKED_ERRORS > 0;
     "
     sql_to_file 'Hosts with errors in host_cache' "$sql" 'mariadb_pfs_hosts_blocked'

     ## Indexes used vs. unused
     sql="
     SELECT SUM(if(count_star>0,1,0)) IDX_USED, SUM(if(count_star=0,1,0)) IDX_UNUSED   
     FROM performance_schema.table_io_waits_summary_by_index_usage  
     WHERE index_name IS NOT NULL AND index_name NOT LIKE 'PRIMARY'  
     ORDER BY object_schema, object_name;
     "
     sql_to_file 'Indexes used vs. unused (ingoring PK)' "$sql" 'mariadb_pfs_indexes_used_vs_unused'

     ## List of unused indexes
     sql="
     SELECT object_schema AS \`Schema\`, object_name AS \`Table\`, index_name AS \`Index\`
     FROM performance_schema.table_io_waits_summary_by_index_usage
     WHERE index_name IS NOT NULL
     AND count_star = 0
     AND index_name NOT LIKE 'PRIMARY'
     ORDER BY object_schema, object_name;
     "
     sql_to_file 'List of unused indexes' "$sql" 'mariadb_pfs_indexes_unused'

     ## Top 20 statements creating tmp tables to disk
     sql="
     SELECT schema_name, substr(digest_text, 1, 100) AS statement,     
     count_star AS cnt, sum_created_tmp_disk_tables AS tmp_disk_tables,     
     sum_created_tmp_tables AS tmp_tables
     FROM performance_schema.events_statements_summary_by_digest
     WHERE sum_created_tmp_disk_tables > 0 OR sum_created_tmp_tables > 0
     ORDER BY tmp_disk_tables desc limit 20;
     "
     sql_to_file 'Top 20 statements creating tmp tables to disk' "$sql" 'mariadb_pfs_tmp_to_disk'

     ## Tmp disk tables events/who
     sql="
     SELECT user, host, event_name, count_star AS cnt, 
       sum_created_tmp_disk_tables AS tmp_disk_tables
     FROM performance_schema.events_statements_summary_by_account_by_event_name  
     WHERE sum_created_tmp_disk_tables  > 0 order by cnt desc;
     "
     sql_to_file 'Tmp disk tables events/who' "$sql" 'mariadb_pfs_tmp_to_disk_event'

     ## Top 20 statements performing full table scans
     sql="
     SELECT schema_name, substr(digest_text, 1, 100) AS statement, 
       count_star AS cnt, sum_select_scan AS full_table_scan 
     FROM performance_schema.events_statements_summary_by_digest  
     WHERE sum_select_scan > 0 
     ORDER BY sum_select_scan desc limit 20;
     "
     sql_to_file 'Top 20 statements performing full table scans' "$sql" 'mariadb_pfs_full_scan'

     ## Full table scans events/who
     sql="
     SELECT user, host, event_name, count_star AS cnt, sum_select_scan  AS full_table_scan  
     FROM performance_schema.events_statements_summary_by_account_by_event_name  
     WHERE sum_select_scan > 0 order by cnt desc;
     "
     sql_to_file 'Full table scans events/who' "$sql" 'mariadb_pfs_full_scan_event'

     ## Account which never connected since last start-up
     sql="
     SELECT DISTINCT m_u.user, m_u.host
     FROM mysql.user m_u
     LEFT JOIN performance_schema.accounts ps_a 
     ON m_u.user = ps_a.user AND m_u.host = ps_a.host
     WHERE ps_a.user IS NULL
     ORDER BY m_u.user;
     "
     sql_to_file 'Account which never connected since last start-up' "$sql" 'mariadb_pfs_account_never_connect_since_start'

     ## Users which never connected since last start-up
     sql="
     SELECT DISTINCT m_u.user
     FROM mysql.user m_u
     LEFT JOIN performance_schema.users ps_u ON m_u.user = ps_u.user
     WHERE ps_u.user IS NULL
     ORDER BY m_u.user;
     "
     sql_to_file 'Users which never connected since last start-up' "$sql" 'mariadb_pfs_user_never_connect_since_start'

     ## Totally unused account
     ## This P_S query joins against some I_S tables which could cause issues with large numbers of tables
     if [ "$check_numbers" = "true" ]; then
       sql="
       SELECT DISTINCT m_u.user, m_u.host
       FROM mysql.user m_u
       LEFT JOIN performance_schema.accounts ps_a 
         ON m_u.user = ps_a.user AND ps_a.host = m_u.host
       LEFT JOIN information_schema.views is_v 
         ON is_v.DEFINER = CONCAT(m_u.User, '@', m_u.Host) AND is_v.security_type = 'DEFINER'
       LEFT JOIN information_schema.routines is_r ON is_r.DEFINER = CONCAT(m_u.User, '@', m_u.Host) AND is_r.security_type = 'DEFINER'
       LEFT JOIN information_schema.events is_e ON is_e.definer = CONCAT(m_u.user, '@', m_u.host)
       LEFT JOIN information_schema.triggers is_t ON is_t.definer = CONCAT(m_u.user, '@', m_u.host)
       WHERE ps_a.user IS NULL
         AND is_v.definer IS NULL
         AND is_r.definer IS NULL
         AND is_e.definer IS NULL
         AND is_t.definer IS NULL
       ORDER BY m_u.user, m_u.host;
       "
       sql_to_file 'Totally unused account (never connected since last restart and not used to check SP or Views)' "$sql" 'mariadb_pfs_account_tot_not_used'
     fi
     
     ##Bad queries sum by users
     sql="
     SELECT user, host, event_name, 
       sum_created_tmp_disk_tables AS tmp_disk_tables, 
       sum_select_full_join AS full_join, 
       sum_select_range_check AS range_check, 
       sum_sort_merge_passes AS sort_merge, 
       sum_sort_scan AS sort_scan, 
       sum_select_scan AS full_scan
     FROM performance_schema.events_statements_summary_by_account_by_event_name
     WHERE sum_created_tmp_disk_tables > 0
       OR sum_select_full_join > 0
       OR sum_select_range_check > 0
       OR sum_sort_merge_passes > 0
       OR sum_sort_scan > 0
       OR sum_select_scan > 0
     ORDER BY sum_sort_merge_passes DESC
     LIMIT 20;      
     "
     sql_to_file 'Bad queries sum by users (top 20)' "$sql" 'mariadb_pfs_bad_queries_sum'
   fi

   ######
   mariadb $mariadb_options -NBe 'select now()' > "$out_dir/mariadb_collect_end"
   echo "All Done."

   if [ $TARRESULT == true ]; then
     echo "Compressing..."
     dir=`pwd`
     pushd ${out_dir}
     tar -czf ${dir}/${out_dir}.mdbo ./
     popd
     rm -rf ${out_dir}
     echo "Filename:" ${dir}/${out_dir}.mdbo
   else
     echo "Skipped results compression."
     echo "Directory name:" ${out_dir}
   fi

   echo "All tasks finished."

}

# ###########################################################################
# End audit_environment
# ###########################################################################

# ###########################################################################
# collect_outputs package
# ###########################################################################
function collect_outputs() {
   # This function consolidates the outputs into one tarball containing the full collections.

   local dir="${OPT_SUPPORT_OUTPUT_DIR:-`pwd`}"
   local output_met="${dir}/`hostname`_${OPT_SUPPORT_ANNOTATION:-""}metrics_`date +%F`.mdbo"
   local output_env="${dir}/`hostname`_${OPT_SUPPORT_ANNOTATION:-""}environment_`date +%F`.mdbo"
   local final_output="${dir}/`hostname`_${OPT_SUPPORT_ANNOTATION:-""}collection_`date +%F`.mdbo"

   if [ -f $output_env ] && [ -f $output_met ]; then
      tar -czf $final_output $output_env $output_met
      rm -f $output_env 2>/dev/null
      rm -f $output_met 2>/dev/null
   elif [ -f $output_env ]; then
      mv $output_env $final_output
   elif [ -f $output_met ]; then
      mv $output_met $final_output
   fi

}
# ###########################################################################
# End collect_outputs
# ###########################################################################

# ##############################################################################
# The main() function is called at the end of the script.  This makes it
# testable.  Major bits of parsing are separated into functions for testability.
# ##############################################################################
main () { 
   local PTFUNCNAME=main;
   trap sigtrap HUP INT TERM

   # Begin by setting the $PATH to include some common locations that are not
   # always in the $PATH, including the "sbin" locations, and some common
   # locations for proprietary management software, such as RAID controllers.
   export PATH="${PATH}:/usr/local/bin:/usr/bin:/bin:/usr/libexec"
   export PATH="${PATH}:/usr/local/sbin:/usr/sbin:/sbin"
   export BASEDIR=`pwd`

   # If the programs we need don't exist, try to get them.
   # Percona Toolkit tools:
   for prog in mariadb-system-summary mariadb-database-summary; do
      # A var can't be named "PR_mariadb-stacktrace" so we chop off "mariadb-" to get
      # the program's basename, resulting in "PR_stacktrace".
      prog_base=${prog#"mariadb-"}
      prog_base=$(echo "$prog_base" | tr -d -)
      if which "$prog" >/dev/null 2>&1 ; then
         eval "PR_$prog_base"="$(which "$prog")"
      elif [ -f "$prog" -a -x "$prog" ]; then
         eval "PR_$prog_base"="./$prog"
      elif [ -f "${BASEDIR}/$prog" -a -x "${BASEDIR}/$prog" ]; then
         eval "PR_$prog_base"="${BASEDIR}/$prog"
      # elif which "curl" >/dev/null 2>&1; then
      #    echo "Fetching $prog" >&2
      #    curl -L "https://www.percona.com/get/$prog" > "$prog" && chmod +x "$prog"
      #    eval "PR_$prog_base"="./$prog"
      else
         echo "Cannot find or fetch required program: $prog" >&2
         exit 1
      fi 
   done

   systemsummary_cmd="$PR_systemsummary"
   for option in "config" "read-samples" "save-samples" "sleep" "summarize-mounts" \
      "summarize-network" "summarize-processes"
   do
      option_val=$(echo "OPT_$option" | sed 's/-/_/g' | tr '[:lower:]' '[:upper:]')
      eval "option_val=\$$option_val"

      if [ ! -z "$option_val" ]; then
         # if [ "$option_val" = "yes" ]; then option_val=""; fi
         systemsummary_cmd="$systemsummary_cmd --$option $option_val"
      fi
   done

   case "$OS" in
      Darwin)
         echo "WARN: Running against a MariaDB server running on MacOS is not supported." >&2
         eval "$systemsummary_cmd | head -n 1"
         ;;
      Linux)
         eval "$systemsummary_cmd | head -n -1"
         ;;
      *)
         echo "OS is misunderstood, $systemsummary_cmd may not run as expected"
         echo "Please file a JIRA at jira.mariadb.org/projects/TOOLS with the output of \`uname\`"
         echo "With a label of \"mariadb-summary\"."
         eval "$systemsummary_cmd | head -n -1"
         ;;
   esac

   dbsummary_cmd="$PR_databasesummary"
   for option in "all-databases" "ask-pass" "config" "databases" "defaults-file" \
      "host" "password" "port" "read-samples" \
      "save-samples" "sleep" "socket" "user"
   do
      option_val=$(echo "OPT_$option" | sed 's/-/_/g' | tr '[:lower:]' '[:upper:]')
      eval "option_val=\$$option_val"

      if [ ! -z "$option_val" ]; then
         # if [ "$option_val" = "yes" ]; then option_val=""; fi
         dbsummary_cmd="$dbsummary_cmd --$option $option_val"
      fi
   done

   eval "$dbsummary_cmd"
}

sigtrap() { local PTFUNCNAME=sigtrap;
   warn "Caught signal, forcing exit"
   rm_tmpdir
   exit $EXIT_STATUS
}

debug_mode_explanation() {
   echo "########### DEBUG MODE ###########"
   echo "This mode is a more verbose output mode."
   echo "It is intended to be used in development."
   echo "There are no additional explanations available."
   echo "########### END DEBUG MODE ###########"
}

# Execute the program if it was not included from another file.  This makes it
# possible to include without executing, and thus test.
if    [ "${0##*/}" = "$TOOL" ] \
   || [ "${0##*/}" = "bash" -a "${_:-""}" = "$0" ]; then

   # Set up temporary dir.
   mk_tmpdir
   # Parse command line options.
   parse_options "$0" "${@:-""}"

   if [ -n "${OPT_HELP}" ] && [ -n "${OPT_DEBUG}" ]; then
      debug_mode_explanation
      usage_or_errors "$0"
      exit 2
   fi
   
   usage_or_errors "$0"
   po_status=$?
   rm_tmpdir

   if [ $po_status -ne 0 ]; then
      exit $po_status
   fi

   if [ -n "${OPT_DEBUG}" ]; then
      echo "########### DEBUG MODE ###########"
      echo "########### START VARIABLES ###########"
      declare -p | grep OPT_
      echo "########### END VARIABLES ###########"
   fi

   if [ "$OPT_SUPPORT_METRICS" -ge 0 ]; then
      audit_metrics
      collect_outputs
   elif [ $OPT_SUPPORT_ENV == true ] 2>/dev/null ; then
      audit_environment
      collect_outputs
   elif [ "${OPT_SUPPORT}" == "yes" ] 2>/dev/null || [ "${OPT_SUPPORT}" -ge 0 ] 2>/dev/null; then
      OPT_SUPPORT_CHECKALL="yes"
      audit_environment
      audit_metrics ${OPT_SUPPORT}
      collect_outputs
   fi

   main "${@:-""}"
fi


# ############################################################################
# Documentation
# ############################################################################
:<<'DOCUMENTATION'
=pod

=head1 NAME

mariadb-summary - Summarize system information nicely.

=head1 SYNOPSIS

Usage: mariadb-summary

mariadb-summary conveniently summarizes the status and configuration of
a database and its underlying server. It is not a tuning tool or diagnosis tool.
It produces a report that is easy to diff and can be pasted into emails without
losing the formatting. This tool works well on many types of Unix systems.

=head1 RISKS

mariadb-summary is mature, proven in the real world, and well tested,
but all database tools can pose a risk to the system and the database
server.  Before using this tool, please:

=over

=item * Read the tool's documentation

=item * Test the tool on a non-production server

=item * Backup your production server and verify the backups

=back

=head1 DESCRIPTION

mariadb-summary runs mariadb-system-summary and mariadb-database-summary together.

These tools run a large variety of commands to inspect system and MariaDB
status and configuration.

It works best when executed as a privileged user, but will also work without 
privileges, although some output might not be possible to generate without root.

=head1 OUTPUT

See mariadb-system-summary and mariadb-database-summary documentation for output
details.

=head1 OPTIONS

=over

=item --all-databases

mariadb-dump and summarize all databases.  See L<"--databases">.

=item --ask-pass

Prompt for a password when connecting to MariaDB.

=item --config

type: string

Read this comma-separated list of config files.  If specified, this must be the
first option on the command line.

=item --databases

type: string

mariadb-dump and summarize this comma-separated list of databases.  Specify
L<"--all-databases"> instead if you want to dump and summary all databases.

=item --defaults-file

short form: -F; type: string

Only read mariadb options from the given file.  You must give an absolute
pathname.

=item --debug

Development use only.

=item --help

Print help and exit.

=item --host

short form: -h; type: string

Host to connect to.

=item --password

short form: -p; type: string

Password to use when connecting.
If password contains commas they must be escaped with a backslash: "exam\,ple"

=item --port

short form: -P; type: int

Port number to use for connection.

=item --read-samples

type: string

Create a report from the files in this directory.

=item --save-samples

type: string

Save the collected data in this directory.

=item --sleep

type: int; default: 5

How long to sleep when gathering samples from vmstat.

=item --socket

short form: -S; type: string

Socket file to use for connection.

=item --summarize-mounts

default: yes; negatable: yes

Report on mounted filesystems and disk usage.

=item --summarize-network

default: yes; negatable: yes

Report on network controllers and configuration.

=item --summarize-processes

default: yes; negatable: yes

Report on top processes and C<vmstat> output.

=item --support

type: integer; default: -1

Option intended for development use only.

=item --support-annotation

type: string; default: ""

Option intended for development use only.

=item --support-checkall

type: boolean; default: true

Option intended for development use only.

=item --support-env

Option intended for development use only.

=item --support-innodb-mutex

type: boolean; default: true

Option intended for development use only.

=item --support-limit

type: integer; default: 10000

Option intended for development use only.

=item --support-memory

type: boolean; default: true

Option intended for development use only.

=item --support-metrics

type: integer; default: -1

Option intended for development use only.

=item --support-mounts

type: boolean; default: true

Option intended for development use only.

=item --support-not-root

type: boolean; default: false

Option intended for development use only.

=item --support-output-dir

type: string;

Option intended for development use only.

=item --support-pid

type: integer

Option intended for development use only.

=item --support-process-list

type: boolean; default: true

Option intended for development use only.

=item --support-replica-status

type: boolean; default: false

Option intended for development use only.

=item --support-sky

type: boolean; default: false

Option intended for development use only.

=item --support-variables

type: boolean; default: true

Option intended for development use only.

=item --support-tar-result

type: boolean; default: true

Option intended for development use only.`

=item --user

short form: -u; type: string

User for login if not current user.

=item --version

Print tool's version and exit.

=back

=head1 ENVIRONMENT

This tool does not use any environment variables.

=head1 SYSTEM REQUIREMENTS

This tool requires the Bourne shell (F</bin/sh>).

=head1 AUTHORS

Cole Busby, Manjot Singh

=head1 ABOUT THIS MARIADB TOOL

This tool is part of MariaDB client tools. This MariaDB Tool was created in 
August, 2019, based on Percona Toolkit which was 
forked from two projects in June, 2011: Maatkit and Aspersa.  Those projects 
were created by Baron Schwartz and primarily developed by him and Daniel Nichter.

=head1 COPYRIGHT, LICENSE, AND WARRANTY

This program is copyright 2019-2022 MariaDB Corporation and/or its affiliates,
2011-2018 Percona LLC and/or its affiliates, 2010-2011 Baron Schwartz.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 VERSION

mariadb-summary 6.0.2.2

=cut

DOCUMENTATION
